"""
OBD Controller
"""
import datetime
import pandas
import re

from io import StringIO
from typing import List
from structlog import get_logger

from app.constants.obd import CarSensorID, CSV_SENSOR_MAP
from app.controllers import BaseController
from app.controllers.obd.session import SessionController
from app.models.obd.car import CarState
from app.models.obd.session import OBDSession
from app.models.user import User


LOGGER = get_logger(__name__)


class OBDControllerError(Exception):
    """ Exception class for OBD Controller """
    pass


class OBDController(BaseController):
    """
    Controller class for OBD-related data manipulations.
    """
    SENSOR_CONTROLLER_CLASSES = []

    def _resolve_date_from_csv_row(self, csv_row: dict):
        """ Resolves a datetime from a certain row in a CSV """
        date_str = csv_row[CSV_SENSOR_MAP[CarSensorID.DATE]]
        return datetime.datetime.strptime(date_str, '%d-%b-%Y %H:%M:%S.%f')

    def _resolve_user(self, data: dict):
        """
        Resolves user from data.

        Raises:
            - OBDControllerError:
                If user email is not found in <data>;
                If there is no user corresponding to the email found in <data>;

        Args:
            - data (dict): Map of arguments received by TORQUE request.

        Returns:
            - user (app.models.user.User): User instance.
        """
        user_email = data.get('eml')
        if not user_email:
            raise OBDControllerError('User email not found')

        user: User = self.db_session.query(User).filter(User.email == user_email).first()
        if not user:
            raise OBDControllerError('User does not exist')

        return user

    def process_sensor_params(self, data: dict):
        """
        Process data receive from TORQUE.
        If identifies that the data is composed by keys identifying sensor specs, will register such specs in the DB.
        Sensors currently considered are described in <app.constants.obd.CarSensorID>.

        Args:
            - data (dict): Data to be processed.
        """
        LOGGER.info('Receiving sensor data from TORQUE', **data)
        has_non_value_keys = any(filter(re.compile(f'.*(unit|user).*', re.IGNORECASE).match, data.keys()))
        if has_non_value_keys:
            LOGGER.info('Will ignore request since it\'s related to sensor params')
            return

        user = self._resolve_user(data)
        LOGGER.info(f'Request is attached to {user.first_name} {user.last_name}', user_id=user.id)
        session = SessionController(user_id=user.id).get_or_create(data['session'])
        LOGGER.info('Resolved session to proceed', **session.to_dict())

        car_state = CarState.create_from_torque(self.db_session, session, data)
        LOGGER.info('Created Car State', **car_state.to_dict())
        self.db_session.commit()

    def process_csv(self, user: User, csv_file):
        """
        Will process a CSV file generated by the TORQUE application, registering the values for each
        considered sensor in the database.

        Args:
            - user (app.models.user.User): User instance;
            - csv_file (werkzeug.FileStorage): A file representation of the CSV file created by TORQUE.
        """
        self.db_session.rollback()
        csv = pandas.read_csv(StringIO(csv_file.read().decode('utf-8')))
        missing_cols = [col_name for col_name in CSV_SENSOR_MAP.values() if col_name not in csv.columns.values]
        if missing_cols:
            raise OBDControllerError(f'CSV is missing the following columns: {", ".join(missing_cols)}')

        csv = csv[CSV_SENSOR_MAP.values()]
        start_datetime = self._resolve_date_from_csv_row(csv.iloc[0])
        gen_session_id = str(start_datetime.timestamp()).replace('.', '')[:12]

        if self.db_session.query(OBDSession).filter(OBDSession.id == gen_session_id).first():
            return

        session = OBDSession.create(self.db_session, id=gen_session_id, user_id=user.id, date=start_datetime)
        _ = CarState.create_from_csv(self.db_session, session, csv)
        self.db_session.commit()
